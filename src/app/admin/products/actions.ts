"use server";

import { createSupabaseAdminClient } from "@/utils/supabase/server";
import { revalidatePath } from "next/cache";

export interface ProductVariantInput {
  material_id: string;
  size_id: string;
  thickness_id: string;
  price: number;
  compare_at_price?: number | null;
  cost_per_item?: number | null;
  is_default?: boolean;
}

export interface ProductImageInput {
  storage_path: string;
  thumbnail_path?: string | null;
  medium_path?: string | null;
  large_path?: string | null;
  display_order: number;
  blurhash?: string | null;
  alt_text?: string | null;
  processing_status?: string;
  is_primary?: boolean;
}

export interface CreateProductInput {
  name: string;
  slug: string;
  description: string;
  category_id?: string | null;
  status: "draft" | "active" | "archived";
  is_featured: boolean;
  seo_title?: string | null;
  seo_description?: string | null;
  variants: ProductVariantInput[];
  images: ProductImageInput[];
}

export interface UpdateProductInput extends CreateProductInput {
  id: string;
}

export async function createProduct(input: CreateProductInput) {
  try {
    const supabase = await createSupabaseAdminClient();

    // Validate that we have at least one image
    if (!input.images || input.images.length === 0) {
      return {
        success: false,
        error: "Please upload at least one product image",
      };
    }

    // Validate that we have at least one variant
    if (!input.variants || input.variants.length === 0) {
      return {
        success: false,
        error: "Add at least one variant",
      };
    }

    // Prepare product data by removing empty strings
    const cleanedProductData = Object.fromEntries(
      Object.entries({
        name: input.name,
        slug: input.slug,
        description: input.description,
        category_id: input.category_id,
        status: input.status,
        is_featured: input.is_featured,
        seo_title: input.seo_title,
        seo_description: input.seo_description,
      })
        .map(([key, value]) => [key, value === "" ? null : value])
        .filter(([_, value]) => value !== null && value !== undefined)
    );

    // 1. Create the product
    const { data: product, error: productError } = await supabase
      .from("products")
      .insert(cleanedProductData)
      .select()
      .single();

    if (productError || !product) {
      console.error("Error creating product:", productError);
      return {
        success: false,
        error: productError?.message || "Failed to create product",
      };
    }

    // 2. Create variants
    const variantsData = input.variants.map((variant) => ({
      product_id: product.id,
      material_id: variant.material_id,
      size_id: variant.size_id,
      thickness_id: variant.thickness_id,
      price: variant.price,
      compare_at_price: variant.compare_at_price || null,
      cost_per_item: variant.cost_per_item || null,
      is_default: variant.is_default || false,
      sku: "", // SKU will be auto-generated by database trigger
    }));

    const { error: variantsError } = await supabase
      .from("product_variants")
      .insert(variantsData);

    if (variantsError) {
      console.error("Error creating variants:", variantsError);
      // Rollback: delete the product
      await supabase.from("products").delete().eq("id", product.id);
      return {
        success: false,
        error: variantsError.message || "Failed to create product variants",
      };
    }

    // 3. Create images
    const imagesData = input.images.map((image) => ({
      product_id: product.id,
      storage_path: image.storage_path,
      thumbnail_path: image.thumbnail_path || null,
      medium_path: image.medium_path || null,
      large_path: image.large_path || null,
      display_order: image.display_order,
      blurhash: image.blurhash || null,
      alt_text: image.alt_text || null,
      processing_status: image.processing_status || "completed",
      is_primary: image.is_primary || false,
    }));

    const { error: imagesError } = await supabase
      .from("product_images")
      .insert(imagesData);

    if (imagesError) {
      console.error("Error creating images:", imagesError);
      // Rollback: delete the product (cascade will delete variants)
      await supabase.from("products").delete().eq("id", product.id);
      return {
        success: false,
        error: imagesError.message || "Failed to create product images",
      };
    }

    // Revalidate the products page
    revalidatePath("/admin/products");

    return {
      success: true,
      data: product,
    };
  } catch (error: any) {
    console.error("Error in createProduct:", error);
    return {
      success: false,
      error: error.message || "An unexpected error occurred",
    };
  }
}

export async function updateProduct(input: UpdateProductInput) {
  try {
    console.log("Creating admin client for update...");
    const supabase = await createSupabaseAdminClient();
    console.log("Admin client created successfully");

    // Validate that we have at least one image
    if (!input.images || input.images.length === 0) {
      return {
        success: false,
        error: "Please upload at least one product image",
      };
    }

    // Validate that we have at least one variant
    if (!input.variants || input.variants.length === 0) {
      return {
        success: false,
        error: "Add at least one variant",
      };
    }

    // Prepare product data by removing empty strings
    const cleanedProductData = Object.fromEntries(
      Object.entries({
        name: input.name,
        slug: input.slug,
        description: input.description,
        category_id: input.category_id,
        status: input.status,
        is_featured: input.is_featured,
        seo_title: input.seo_title,
        seo_description: input.seo_description,
      })
        .map(([key, value]) => [key, value === "" ? null : value])
        .filter(([_, value]) => value !== null && value !== undefined)
    );

    // 1. First verify the product exists
    console.log("Checking if product exists with ID:", input.id);
    const { data: existingProduct, error: checkError } = await supabase
      .from("products")
      .select("id")
      .eq("id", input.id)
      .single();

    if (checkError || !existingProduct) {
      console.error("Product not found:", checkError);
      return {
        success: false,
        error: `Product with ID ${input.id} not found`,
      };
    }

    console.log("Product exists, proceeding with update");
    console.log("Update data:", cleanedProductData);

    // 2. Update the product - don't use .single() as it fails if no rows are affected
    const { data: products, error: productError, count } = await supabase
      .from("products")
      .update(cleanedProductData)
      .eq("id", input.id)
      .select();

    console.log("Update result - count:", count, "error:", productError, "data:", products);

    if (productError) {
      console.error("Error updating product:", productError);
      return {
        success: false,
        error: productError?.message || "Failed to update product",
      };
    }

    // If no rows were returned, it's because PostgreSQL detected no changes
    // This is expected behavior when data is identical - treat as success
    let product;
    if (!products || products.length === 0) {
      console.log("No rows returned from update - fetching current product (likely no changes detected)");
      const { data: currentProduct, error: fetchError } = await supabase
        .from("products")
        .select("*")
        .eq("id", input.id)
        .single();

      if (fetchError || !currentProduct) {
        console.error("Product not found:", fetchError);
        return {
          success: false,
          error: "Product not found",
        };
      }

      product = currentProduct;
      console.log("Update successful - no changes needed");
    } else {
      product = products[0];
      console.log("Product updated successfully:", product.id);
    }

    // 3. Delete existing variants
    console.log("Deleting existing variants for product:", input.id);
    const { error: deleteVariantsError } = await supabase
      .from("product_variants")
      .delete()
      .eq("product_id", input.id);

    if (deleteVariantsError) {
      console.error("Error deleting variants:", deleteVariantsError);
      return {
        success: false,
        error: deleteVariantsError.message || "Failed to delete old variants",
      };
    }

    // 3. Create new variants
    const variantsData = input.variants.map((variant) => ({
      product_id: product.id,
      material_id: variant.material_id,
      size_id: variant.size_id,
      thickness_id: variant.thickness_id,
      price: variant.price,
      compare_at_price: variant.compare_at_price || null,
      cost_per_item: variant.cost_per_item || null,
      is_default: variant.is_default || false,
      sku: "", // SKU will be auto-generated by database trigger
    }));

    const { error: variantsError } = await supabase
      .from("product_variants")
      .insert(variantsData);

    if (variantsError) {
      console.error("Error creating variants:", variantsError);
      return {
        success: false,
        error: variantsError.message || "Failed to create product variants",
      };
    }

    // 4. Delete existing images
    const { error: deleteImagesError } = await supabase
      .from("product_images")
      .delete()
      .eq("product_id", input.id);

    if (deleteImagesError) {
      console.error("Error deleting images:", deleteImagesError);
      return {
        success: false,
        error: deleteImagesError.message || "Failed to delete old images",
      };
    }

    // 5. Create new images
    const imagesData = input.images.map((image) => ({
      product_id: product.id,
      storage_path: image.storage_path,
      thumbnail_path: image.thumbnail_path || null,
      medium_path: image.medium_path || null,
      large_path: image.large_path || null,
      display_order: image.display_order,
      blurhash: image.blurhash || null,
      alt_text: image.alt_text || null,
      processing_status: image.processing_status || "completed",
      is_primary: image.is_primary || false,
    }));

    const { error: imagesError } = await supabase
      .from("product_images")
      .insert(imagesData);

    if (imagesError) {
      console.error("Error creating images:", imagesError);
      return {
        success: false,
        error: imagesError.message || "Failed to create product images",
      };
    }

    // Revalidate the products page
    revalidatePath("/admin/products");
    revalidatePath(`/admin/products/${input.id}`);

    return {
      success: true,
      data: product,
    };
  } catch (error: any) {
    console.error("Error in updateProduct:", error);
    return {
      success: false,
      error: error.message || "An unexpected error occurred",
    };
  }
}
